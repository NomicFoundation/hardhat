import type {
  NpmPackageResolvedFile,
  ProjectResolvedFile,
  Remapping,
  ResolvedFile,
  ResolvedNpmPackage,
  Resolver,
} from "./types.js";

import path from "node:path";

import {
  HardhatError,
  assertHardhatInvariant,
} from "@ignored/hardhat-vnext-errors";
import { ensureError } from "@ignored/hardhat-vnext-utils/error";
import {
  FileNotFoundError,
  exists,
  getFileTrueCase,
  getRealPath,
  readJsonFile,
  readUtf8File,
} from "@ignored/hardhat-vnext-utils/fs";

import { ResolutionError, resolve } from "./node-resolution.js";
import {
  applyValidRemapping,
  parseRemappingString,
  selectBestRemapping,
} from "./remappings.js";
import { ResolvedFileType } from "./types.js";

// Things to note:
//  - This resolver assumes that the root of the project is the folder with the
//    closest package.json to the config file.
//  - Each file system file is resolved to a single ResolvedFile, with a unique
//    source name.
//  - Files within the project have their relative path as their source name.
//  - Files within npm packages have source names that start with `npm/` and
//    contain the package name and version. e.g. `npm/package@1.2.3/path.sol`.
//  - Files within npm packages that are part of a monorepo are resolved like
//    npm pacakges, but with the version `local`.
//  - This resolver does not support `package.json#exports`.
//  - This resolver fails if an import has a casing different from that of the
//    file system.
//  - We do not allow users to remap the imports present in files within npm
//    packages, by forbidding user remappings with context and starting with
//    `npm/`.
//  - We do allow users to remap imports of non-npm files, including remmapping
//    them into file within npm packages.
//  - Every import in an npm file is either relative or remapped by a remapping
//    generated by the resolver.
//  - A direct import (i.e. not relative) is considered to be local within the
//    the project/package if it is a bare file name (not in a directory), or if
//    the first directory exists in the project/package.
//  - The direct import "hardhat/console.sol" is a special case and it is never
//    considered to be local. And we only remap `hardhat/console.sol`.
//  - Local imports within the project may be remapped by user remappings, but
//    not by the resolver.
//  - Imports into npm packages are always remapped, if not by the user, by the
//    resolver.
//  - Direct local improts within npm package are always remapped by the
//    resolver.

// TODO: Windows and source names with \ instead of /
// TODO: Forbid local direct imports to `npm/...`, and local fiels in `npm/`

interface UserRemapping {
  rawFormat: string;
  context: string;
  prefix: string;
  target: string;
  targetNpmPackage?: ResolvedNpmPackage;
}

const PROJECT_ROOT_SOURCE_NAME_SENTINEL: unique symbol = Symbol();

export class ResolverImplementation implements Resolver {
  readonly #projectRoot: string;
  readonly #workingDirectory: string;
  readonly #userRemappings: UserRemapping[];

  // A map of all the npm dependencies used in the project and its dependencies
  readonly #dependencyMaps: Map<
    string | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL, // The package's root sourceName
    Map<
      string, // The package that is being imported, as the package name in the import
      ResolvedNpmPackage | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL
    >
  > = new Map();

  // A map of all the prefixes that a package may need to avoid being affected
  // by user remappings.
  readonly #localPrefixesByPackage: Map<string, Set<string>> = new Map();

  // A cache from absolute path to resolved file
  readonly #cacheBySourceName: Map<string, ResolvedFile> = new Map();

  public static async create(
    projectRoot: string,
    userRemappingStrings: string[],
    workingDirectory?: string,
  ): Promise<Resolver> {
    const userRemappings = await Promise.all(
      userRemappingStrings.map((remappingString) =>
        validateAndResolveUserRemapping(projectRoot, remappingString),
      ),
    );

    return new ResolverImplementation(
      workingDirectory !== undefined
        ? await getRealPath(workingDirectory)
        : process.cwd(),
      projectRoot,
      userRemappings,
    );
  }

  private constructor(
    workingDirectory: string,
    projectRoot: string,
    userRemappings: UserRemapping[],
  ) {
    this.#projectRoot = projectRoot;
    this.#workingDirectory = workingDirectory;
    this.#userRemappings = userRemappings;
    this.#dependencyMaps.set(PROJECT_ROOT_SOURCE_NAME_SENTINEL, new Map());
  }

  public async resolveProjectFile(
    absoluteFilePath: string,
  ): Promise<ProjectResolvedFile> {
    if (!absoluteFilePath.startsWith(this.#projectRoot)) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.RESOLVING_INCORRECT_FILE_AS_PROJECT_FILE,
        {
          file: this.#userFriendlyPath(absoluteFilePath),
        },
      );
    }

    const relativeFilePath = path.relative(this.#projectRoot, absoluteFilePath);

    // Contrary to imports, it's fine if we don't have the right casing here.
    //
    // The cache may be less effetive if the casing was wrong, but as most of
    // the time these absolute paths are read from the file system, they'd have
    // the right casing in general.
    let sourceName = relativeFilePath;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
      return cached as ProjectResolvedFile;
    }

    let trueCasePath: string;
    try {
      trueCasePath = await getFileTrueCase(this.#projectRoot, relativeFilePath);
    } catch (error) {
      ensureError(error, FileNotFoundError);

      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.RESOLVING_NONEXISTENT_PROJECT_FILE,
        { file: this.#userFriendlyPath(absoluteFilePath) },
        error,
      );
    }

    sourceName = trueCasePath;

    // Maybe it was cached with the right casing
    const cachedWithTheRightCasing = this.#cacheBySourceName.get(sourceName);
    if (cachedWithTheRightCasing !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions
      -- If it was, it's a ProjectResolvedFile */
      return cachedWithTheRightCasing as ProjectResolvedFile;
    }

    const pathWithTheRightCasing = path.join(this.#projectRoot, trueCasePath);

    const resolvedFile: ProjectResolvedFile = {
      type: ResolvedFileType.PROJECT_FILE,
      sourceName,
      path: pathWithTheRightCasing,
      content: await readUtf8File(pathWithTheRightCasing),
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  public async resolveImport(
    from: ResolvedFile,
    importPath: string,
  ): Promise<ResolvedFile> {
    let directImport = importPath;

    if (importPath.startsWith("./") || importPath.startsWith("../")) {
      directImport = path.join(path.dirname(from.sourceName), importPath);

      if (from.type === ResolvedFileType.NPM_PACKGE_FILE) {
        if (!directImport.startsWith(from.package.rootSourceName)) {
          throw new Error(
            `Invalid import ${importPath} from ${this.#userFriendlyPath(from.path)}, trying to import outside of the package`,
          );
        }
      } else {
        if (directImport.startsWith("../")) {
          throw new Error(
            `Invalid import ${importPath} from ${this.#userFriendlyPath(from.path)}, trying to import outside of the project`,
          );
        }
      }
    }

    switch (from.type) {
      case ResolvedFileType.PROJECT_FILE:
        return this.#resolveImportFromProjectFile({
          from,
          importPath,
          directImport,
        });

      case ResolvedFileType.NPM_PACKGE_FILE:
        return this.#resolveImportFromNpmPackageFile({
          from,
          importPath,
          directImport,
        });
    }
  }

  public getRemappings(): Remapping[] {
    const userRemappings = this.#userRemappings.map((remapping) => ({
      context: remapping.context,
      prefix: remapping.prefix,
      target: remapping.target,
    }));

    const remappings: Remapping[] = [];

    for (const [
      fromPackageSourceName,
      dependenciesMap,
    ] of this.#dependencyMaps.entries()) {
      let context: string;

      if (fromPackageSourceName === PROJECT_ROOT_SOURCE_NAME_SENTINEL) {
        context = "";
      } else {
        context = fromPackageSourceName;
      }

      for (const [importedPackage, dependency] of dependenciesMap.entries()) {
        // As `hardhat/console.sol` is resolved through npm, even if the
        // `hardhat/` folder exists in the root of the package/project, we
        // only remap that file.
        // We should revisit this if we exported more solidity files in the
        // hardhat package in the future.
        if (
          dependency !== PROJECT_ROOT_SOURCE_NAME_SENTINEL &&
          dependency.name === "hardhat"
        ) {
          const prefix = importedPackage + "/console.sol";
          const target = dependency.rootSourceName + "console.sol";

          remappings.push({ context, prefix, target });
        } else {
          const prefix = importedPackage + "/";

          const target =
            dependency === PROJECT_ROOT_SOURCE_NAME_SENTINEL
              ? ""
              : dependency.rootSourceName;

          remappings.push({ context, prefix, target });
        }
      }
    }

    // TODO: Always order this in a consistent way
    for (const [packageSourceName, prefixes] of this.#localPrefixesByPackage) {
      for (const prefix of prefixes) {
        remappings.push({
          context: packageSourceName,
          prefix,
          target: packageSourceName + prefix,
        });
      }
    }

    // We sort the remappings acording to the remappings selection rules, plus
    // the targets, which shouldn't be needed.
    remappings
      .sort((a, b) => a.target.localeCompare(b.target))
      .sort((a, b) => a.target.length - b.target.length)
      .sort((a, b) => a.prefix.localeCompare(b.prefix))
      .sort((a, b) => a.prefix.length - b.prefix.length)
      .sort((a, b) => a.context.localeCompare(b.context))
      .sort((a, b) => a.context.length - b.context.length);

    return [...userRemappings, ...remappings];
  }

  // >>>>>>>>>> BEGIN SECTION: Import resolution selection
  //
  // The private methods in this section are in charge of selecting which import
  // resolution technique to use, but they don't create any ResolvedFile.
  //
  // These techniques are:
  //  1. Resolving an import to a project file
  //  2. Resolving an import to an npm package remapped by the user
  //  3. Resolving an import from an npm package to one of its own files with a
  //     relative import
  //  4. Resolving an import from an npm package to one of its own files with a
  //     direct import â€” This case is different from 3, as without especial care
  //     it could be affected by one of the user remappings.
  //  5. Resolving an import to a different npm package using our own remmapings

  /**
   * Resolves an import from a project file.
   *
   * This method applies the user remappings, if necessary, and uses the
   * appropriate resolution technique.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but before applying any remapping.
   */
  async #resolveImportFromProjectFile({
    from,
    importPath,
    directImport,
  }: {
    from: ProjectResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    const bestUserRemapping = selectBestRemapping(
      from.sourceName,
      directImport,
      this.#userRemappings,
    );

    if (bestUserRemapping !== undefined) {
      const remappedDirectImport = applyValidRemapping(
        directImport,
        bestUserRemapping,
      );

      // Special case, where a user remapping's target is an npm pacakge
      if (bestUserRemapping.targetNpmPackage !== undefined) {
        // This weird syntax is because TS doesn't realize that
        // bestUserRemapping is Required<UserRemapping> here
        const remapping: Required<UserRemapping> = {
          ...bestUserRemapping,
          targetNpmPackage: bestUserRemapping.targetNpmPackage,
        };

        return this.#resolveImportToNpmPackageRemappedByUser({
          from,
          importPath,
          directImport: remappedDirectImport,
          remapping,
        });
      }

      if (
        !(await this.#isDirectImportLocal(
          this.#projectRoot,
          remappedDirectImport,
        ))
      ) {
        throw new Error(
          `Applying the remapping "${bestUserRemapping.rawFormat}" to the import ${importPath} from ${this.#userFriendlyPath(from.path)} results in an invalid import ${remappedDirectImport}, as it's not a local files. If you are trying to remap into an npm module use the npm/ syntax instead.`,
        );
      }

      return this.#resolveImportToProjectFile({
        from,
        importPath,
        pathWithinTheProject: remappedDirectImport,
      });
    }

    if (await this.#isDirectImportLocal(this.#projectRoot, directImport)) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        pathWithinTheProject: directImport,
      });
    }

    return this.#resolveImportThroughNpm({ from, importPath, directImport });
  }

  /**
   * Resolves an import from an npm file.
   *
   * This method does not apply any remapping that may be present in the npm
   * package.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportFromNpmPackageFile({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<ResolvedFile> {
    // If we wanted to apply its own remappings, this would be the place.
    // Initially we won't support it.

    //
    if (directImport.startsWith(from.package.rootSourceName)) {
      return this.#resolveRelativeImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });
    }

    // This was already a direct import, and may be to the same package.
    // As we allow this imports in the local project files, we should also allow
    // them on npm packages. If we don't projects won't be easily distributable
    // through npm, even if they don't use remappings.
    if (await this.#isDirectImportLocal(from.package.rootPath, directImport)) {
      const resolvedFile = await this.#resolveLocalImportFromNpmPackage({
        from,
        importPath,
        directImport,
      });

      if (!this.#localPrefixesByPackage.has(from.package.rootSourceName)) {
        this.#localPrefixesByPackage.set(
          from.package.rootSourceName,
          new Set(),
        );
      }

      const prefixesNeededByPackage = this.#localPrefixesByPackage.get(
        from.package.rootSourceName,
      );

      assertHardhatInvariant(
        prefixesNeededByPackage !== undefined,
        "We just set this value to a new Set",
      );

      prefixesNeededByPackage.add(
        this.#getDirectImportLocalPrefix(directImport),
      );

      return resolvedFile;
    }

    return this.#resolveImportThroughNpm({ from, importPath, directImport });
  }

  /**
   * This method resolves an import that has to go through the npm resolution
   * process and selects the appropriate technique to resolve it.
   *
   * This method does not apply nor define any remapping, but it populates the
   * `#dependencyMaps` with dependencies that each package uses, so that we can
   * create all the necessary remappings at the end of the resolution process.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * but without applying any remapping.
   */
  async #resolveImportThroughNpm({
    from,
    importPath,
    directImport,
  }: {
    from: ResolvedFile;
    importPath: string;
    directImport: string;
  }): Promise<ResolvedFile> {
    const parsedDirectImport = this.#parseNpmDirectImport(directImport);

    if (parsedDirectImport === undefined) {
      throw new Error(`Invalid npm import ${directImport}`);
    }

    const dependencyMapsKey =
      from.type === ResolvedFileType.PROJECT_FILE
        ? PROJECT_ROOT_SOURCE_NAME_SENTINEL
        : from.package.rootSourceName;

    if (!this.#dependencyMaps.has(dependencyMapsKey)) {
      this.#dependencyMaps.set(dependencyMapsKey, new Map());
    }

    const dependenciesMap = this.#dependencyMaps.get(dependencyMapsKey);

    assertHardhatInvariant(
      dependenciesMap !== undefined,
      "We set the dependency map right above",
    );

    if (!dependenciesMap.has(parsedDirectImport.package)) {
      let newDependency:
        | ResolvedNpmPackage
        | typeof PROJECT_ROOT_SOURCE_NAME_SENTINEL;

      const baseResolutionDirectory =
        from.type === ResolvedFileType.PROJECT_FILE
          ? this.#projectRoot
          : from.package.rootPath;

      const packageJsonResolution = resolve({
        from: baseResolutionDirectory,
        toResolve: parsedDirectImport.package + "/package.json",
      });

      if (packageJsonResolution === ResolutionError.MODULE_NOT_FOUND) {
        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.IMPORTED_NPM_DEPENDENCY_NOT_INSTALLED,
          {
            from: this.#userFriendlyPath(from.path),
            importPath,
          },
        );
      }

      if (packageJsonResolution === ResolutionError.NOT_EXPORTED) {
        throw new HardhatError(
          HardhatError.ERRORS.SOLIDITY.IMPORTED_NPM_DEPENDENCY_THAT_USES_EXPORTS,
          { from: this.#userFriendlyPath(from.path), importPath },
        );
      }

      const packageJsonPath = packageJsonResolution.absolutePath;

      const packageJson = await readJsonFile<{ name: string; version: string }>(
        packageJsonPath,
      );

      if (isPackageJsonFromProject(packageJsonPath, this.#projectRoot)) {
        newDependency = PROJECT_ROOT_SOURCE_NAME_SENTINEL;
      } else {
        const name = packageJson.name;
        const version = isPackageJsonFromMonorepo(
          packageJsonPath,
          this.#projectRoot,
        )
          ? "local"
          : packageJson.version;

        const npmPackage: ResolvedNpmPackage = {
          name,
          version,
          rootPath: path.dirname(packageJsonPath),
          rootSourceName: npmPackageToRootSourceName(name, version),
        };

        newDependency = npmPackage;
      }

      dependenciesMap.set(parsedDirectImport.package, newDependency);
    }

    const dependency = dependenciesMap.get(parsedDirectImport.package);
    assertHardhatInvariant(
      dependency !== undefined,
      "We set the dependency right above",
    );

    if (dependency === PROJECT_ROOT_SOURCE_NAME_SENTINEL) {
      return this.#resolveImportToProjectFile({
        from,
        importPath,
        // If we import a file through npm and end up in the Hardhat project,
        // we are going to remap the package name to "", so that the path
        // section of the parsed direct is in fact the directImport in the
        // context of the package.
        pathWithinTheProject: parsedDirectImport.path,
      });
    }

    return this.#resolveImportToNpmPackage({
      from,
      importPath,
      importedPackage: dependency,
      pathWithinThePackage: parsedDirectImport.path,
    });
  }

  // >>>>>>>>>> END SECTION: Import resolution selection

  // >>>>>>>>>> BEGIN SECTION: Import resolution techniques
  //
  // The private methods in this section implement the different import
  // import resolution techniques, which have been explained in the previous
  // section.

  /**
   * This method implements the import resolution technique number 1: Importing
   * a file that is within the project. Note that this method applies both to
   * imports from project files as well as imports from npm packages that may
   * have the project as a dependency.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param pathWithinTheProject The path within the project to import, after
   * normalizing relative paths, applying user remappings and/or stripping the
   * npm package name.
   */
  async #resolveImportToProjectFile({
    from,
    importPath,
    pathWithinTheProject,
  }: {
    from: ResolvedFile;
    importPath: string;
    pathWithinTheProject: string;
  }): Promise<ProjectResolvedFile> {
    const sourceName = pathWithinTheProject;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a ProjectResolvedFile */
      return cached as ProjectResolvedFile;
    }

    // This is a project file, so if it was imported from a local file, this
    // is the direct import, without any remapping or necessary consideration.
    // If this was imported from an npm package, we are remapping the package
    // name to "", so that the direct import is the same as the relative path.
    const relativePath = pathWithinTheProject;
    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativePath,
      absolutePathToValidateFrom: this.#projectRoot,
    });

    const filePath = path.join(this.#projectRoot, relativePath);

    const resolvedFile: ProjectResolvedFile = {
      type: ResolvedFileType.PROJECT_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 2: A project
   * file has an import that should be resolved to a file in an npm package due
   * to a user remapping.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths,
   * and applying the user remapping.
   * @param remapping The remapping that was applied.
   */
  async #resolveImportToNpmPackageRemappedByUser({
    from,
    importPath,
    directImport,
    remapping,
  }: {
    from: ProjectResolvedFile;
    importPath: string;
    directImport: string;
    remapping: Required<UserRemapping>;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    const relativeFilePath = path.relative(
      npmPackageToRootSourceName(
        remapping.targetNpmPackage.name,
        remapping.targetNpmPackage.version,
      ),
      directImport,
    );

    // We don't add the dependency to `this.#dependencyMaps` because we
    // don't need a new remapping for this package, as it's already
    // remapped by the user.

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativeFilePath,
      absolutePathToValidateFrom: remapping.targetNpmPackage.rootPath,
    });

    const filePath = path.join(
      remapping.targetNpmPackage.rootPath,
      relativeFilePath,
    );

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: remapping.targetNpmPackage,
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 3: A file
   * from an npm package is importing another file from the same package with a
   * relative import.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * It must start with the package's root source name.
   */
  async #resolveRelativeImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = directImport;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    const relativePath = path.relative(
      from.package.rootSourceName,
      directImport,
    );

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: relativePath,
      absolutePathToValidateFrom: from.package.rootPath,
    });

    const filePath = path.join(from.package.rootPath, relativePath);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: from.package,
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);
    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 4: A file
   * from an npm package is importing another file from the same package with a
   * direct import.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param directImport The direct import path, after resolving relative paths.
   * The direct import must be considered local within the package, according to
   * the rules of the `#isDirectImportLocal` method.
   */
  async #resolveLocalImportFromNpmPackage({
    from,
    importPath,
    directImport,
  }: {
    from: NpmPackageResolvedFile;
    directImport: string;
    importPath: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = from.package.rootSourceName + directImport;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: directImport,
      absolutePathToValidateFrom: from.package.rootPath,
    });

    const filePath = path.join(from.package.rootPath, directImport);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: from.package,
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);
    return resolvedFile;
  }

  /**
   * This method implements the import resolution technique number 5: A file,
   * within the project or from an npm pacakge, is importing a file from a
   * different npm package.
   *
   * @param from The file from which the import is being resolved.
   * @param importPath The import path, as written in the source code.
   * @param importedPackage The NpmPackage that is being imported.
   * @param pathWithinThePackage The path to the file to import, within the
   * package. That means, after parsing the direct import, and stripping the
   * package part.
   */
  async #resolveImportToNpmPackage({
    from,
    importPath,
    importedPackage,
    pathWithinThePackage,
  }: {
    from: ResolvedFile;
    importPath: string;
    importedPackage: ResolvedNpmPackage;
    pathWithinThePackage: string;
  }): Promise<NpmPackageResolvedFile> {
    const sourceName = importedPackage.rootSourceName + pathWithinThePackage;
    const cached = this.#cacheBySourceName.get(sourceName);
    if (cached !== undefined) {
      /* eslint-disable-next-line @typescript-eslint/consistent-type-assertions --
      The cache is type-unsafe, but we are sure this is a NpmPackageResolvedFile */
      return cached as NpmPackageResolvedFile;
    }

    await this.#validateExistanceAndCasingOfImport({
      from,
      importPath,
      relativePathToValidate: pathWithinThePackage,
      absolutePathToValidateFrom: importedPackage.rootPath,
    });

    const filePath = path.join(importedPackage.rootPath, pathWithinThePackage);

    const resolvedFile: NpmPackageResolvedFile = {
      type: ResolvedFileType.NPM_PACKGE_FILE,
      sourceName,
      path: filePath,
      content: await readUtf8File(filePath),
      package: importedPackage,
    };

    this.#cacheBySourceName.set(sourceName, resolvedFile);

    return resolvedFile;
  }

  // >>>>>>>>>> END SECTION: Import resolution techniques

  /**
   * This method returns true if a direct import should be considered an import
   * to a local file when evaluated in the context of the Hardhat project.
   */
  async #isDirectImportLocal(
    projectOrPackageRoot: string,
    directImport: string,
  ): Promise<boolean> {
    if (directImport === "hardhat/console.sol") {
      return false;
    }

    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return true;
    }

    const firstDirectory = directImport.substring(0, slash);

    // TODO: Cache this
    return exists(path.join(projectOrPackageRoot, firstDirectory));
  }

  /**
   * Returns the prefix that is used by #isDirectImportLocal to determine if a
   * direct import is local.
   *
   * NOTE: This method does not support `hardhat/console.sol`.
   */
  #getDirectImportLocalPrefix(directImport: string): string {
    const slash = directImport.indexOf("/");

    // If it's a file in the root directory
    if (slash === -1) {
      return directImport;
    }

    const firstDirectory = directImport.substring(0, slash + 1);

    return firstDirectory;
  }

  /**
   * This is an utility method that validates the existance and casing of an
   * imported file as part of the different resolution techniques.
   *
   * `from` and `importPath` are used to provide a user-friendly error message,
   * but the actual validation is done using `relativePathToValidate` and
   * `absolutePathToValidateFrom`.
   *
   * @param from The file with the import.
   * @param importPath The import path, as written in the source code.
   * @param relativePathToValidate The relative path to validate its existance.
   * @param absolutePathToValidateFrom The absolute path from in which the
   * relative path is.
   */
  async #validateExistanceAndCasingOfImport({
    from,
    importPath,
    relativePathToValidate,
    absolutePathToValidateFrom,
  }: {
    from: ResolvedFile;
    importPath: string;
    relativePathToValidate: string;
    absolutePathToValidateFrom: string;
  }) {
    let trueCasePath: string;
    try {
      trueCasePath = await getFileTrueCase(
        absolutePathToValidateFrom,
        relativePathToValidate,
      );
    } catch (error) {
      ensureError(error, FileNotFoundError);

      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.IMPORTED_FILE_DOESNT_EXIST,
        { importPath, from: this.#userFriendlyPath(from.path) },
        error,
      );
    }

    if (relativePathToValidate !== trueCasePath) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.IMPORTED_FILE_WITH_ICORRECT_CASING,
        {
          importPath,
          from: this.#userFriendlyPath(from.path),
          correctCasing: trueCasePath,
        },
      );
    }
  }

  /**
   * Normalizes a path to be user-friendly, by making it relative to the working
   * directory if it's within it.
   */
  #userFriendlyPath(from: string): string {
    if (from.startsWith(this.#workingDirectory)) {
      return path.relative(this.#workingDirectory, from);
    }

    return from;
  }

  /**
   * Parses a direct import as if it were an npm import, returning `undefined`
   * if the format is invalid.
   */
  #parseNpmDirectImport(directImport: string):
    | {
        package: string;
        path: string;
      }
    | undefined {
    const directImportPattern =
      /^(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)\/(?<path>.*)$/;

    const match = directImportPattern.exec(directImport);

    if (match === null) {
      return undefined;
    }

    assertHardhatInvariant(
      match.groups !== undefined,
      "Groups should be defined because they are part of the pattern",
    );

    return { package: match.groups.package, path: match.groups.path };
  }
}

async function validateAndResolveUserRemapping(
  projectRoot: string,
  remappingString: string,
): Promise<UserRemapping> {
  const remapping = parseRemappingString(remappingString);

  if (remapping.context.startsWith("npm/")) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.USER_REMAPPING_WITH_NPM_CONTEXT,
      { remapping: remappingString },
    );
  }

  if (!remapping.target.startsWith("npm/")) {
    return { ...remapping, rawFormat: remappingString };
  }

  const parsed = parseNpmRemappingTarget(remapping.target);

  if (parsed === undefined) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_WITH_INVALID_SYNTAX,
      { remapping: remappingString },
    );
  }

  const { packageName, packageVersion } = parsed;

  const dependencyPackageJsonResolution = resolve({
    from: projectRoot,
    toResolve: `${packageName}/package.json`,
  });

  if (dependencyPackageJsonResolution === ResolutionError.MODULE_NOT_FOUND) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_TO_UNINSTALLED_PACKAGE,
      { remapping: remappingString, package: packageName },
    );
  }

  if (dependencyPackageJsonResolution === ResolutionError.NOT_EXPORTED) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_TO_PACKAGE_USING_EXPORTS,
      { remapping: remappingString, package: packageName },
    );
  }

  const dependencyPackageJsonPath =
    dependencyPackageJsonResolution.absolutePath;

  if (isPackageJsonFromMonorepo(dependencyPackageJsonPath, projectRoot)) {
    if (packageVersion !== "local") {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.REMAPPING_NPM_PACKAGE_AS_MONOREPO,
        {
          remapping: remappingString,
          pacakge: packageName,
          version: packageVersion,
        },
      );
    }
  }

  if (isPackageJsonFromProject(dependencyPackageJsonPath, projectRoot)) {
    throw new HardhatError(
      HardhatError.ERRORS.SOLIDITY.REMAPPING_HARDHAT_PROJECT_AS_MONOREPO_PACKAGE,
      { remapping: remappingString, package: packageName },
    );
  }

  if (isPackageJsonFromNpmPackage(dependencyPackageJsonPath)) {
    const dependencyPackageJson = await readJsonFile<{ version: string }>(
      dependencyPackageJsonPath,
    );

    if (dependencyPackageJson.version !== packageVersion) {
      throw new HardhatError(
        HardhatError.ERRORS.SOLIDITY.REMAPPING_INCORRECT_VERSION,
        {
          remapping: remappingString,
          package: packageName,
          expectedVersion: packageVersion,
          actualVersion: dependencyPackageJson.version,
        },
      );
    }
  }

  const npmPackage: ResolvedNpmPackage = {
    name: packageName,
    version: packageVersion,
    rootPath: path.dirname(dependencyPackageJsonPath),
    rootSourceName: npmPackageToRootSourceName(packageName, packageVersion),
  };

  return {
    ...remapping,
    targetNpmPackage: npmPackage,
    rawFormat: remappingString,
  };
}

function parseNpmRemappingTarget(remappingTarget: string):
  | {
      packageName: string;
      packageVersion: string;
    }
  | undefined {
  const npmTargetPattern =
    /^npm\/(?<package>(?:@[a-z0-9-~._]+\/)?[a-z0-9-~][a-z0-9-~._]*)@(?<version>local|\d+\.\d+\.\d+)\//;

  const match = npmTargetPattern.exec(remappingTarget);

  if (match === null) {
    return undefined;
  }

  assertHardhatInvariant(
    match.groups !== undefined,
    "Groups should be defined because they are part of the pattern",
  );

  return {
    packageName: match.groups.package,
    packageVersion: match.groups.version,
  };
}

function npmPackageToRootSourceName(name: string, version: string): string {
  return `npm/${name}@${version}/`;
}

function isPackageJsonFromMonorepo(
  packageJsonPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonPath.includes("node_modules") &&
    !packageJsonPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromProject(
  packageJsonPath: string,
  projectRoot: string,
): boolean {
  return (
    !packageJsonPath.includes("node_modules") &&
    packageJsonPath.startsWith(projectRoot)
  );
}

function isPackageJsonFromNpmPackage(packageJsonPath: string): boolean {
  return packageJsonPath.includes("node_modules");
}
