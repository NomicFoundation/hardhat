use std::sync::OnceLock;

use bytes::Bytes;
use revm_primitives::{keccak256, Address, B256, U256};

use crate::{
    signature::{Signature, SignatureError},
    transaction::{kind::TransactionKind, request::LegacyTransactionRequest},
};

#[derive(Clone, Debug, Eq)]
#[cfg_attr(
    feature = "fastrlp",
    derive(open_fastrlp::RlpEncodable, open_fastrlp::RlpDecodable)
)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct LegacySignedTransaction {
    #[cfg_attr(feature = "serde", serde(with = "crate::serde::u64"))]
    pub nonce: u64,
    pub gas_price: U256,
    #[cfg_attr(feature = "serde", serde(with = "crate::serde::u64"))]
    pub gas_limit: u64,
    pub kind: TransactionKind,
    pub value: U256,
    #[cfg_attr(feature = "serde", serde(with = "crate::serde::bytes"))]
    pub input: Bytes,
    pub signature: Signature,
    /// Cached transaction hash
    #[cfg_attr(feature = "serde", serde(skip))]
    pub hash: OnceLock<B256>,
}

impl LegacySignedTransaction {
    pub fn nonce(&self) -> &u64 {
        &self.nonce
    }

    pub fn hash(&self) -> &B256 {
        self.hash.get_or_init(|| keccak256(&rlp::encode(self)))
    }

    /// Recovers the Ethereum address which was used to sign the transaction.
    pub fn recover(&self) -> Result<Address, SignatureError> {
        self.signature
            .recover(LegacyTransactionRequest::from(self).hash())
    }
}

impl PartialEq for LegacySignedTransaction {
    fn eq(&self, other: &Self) -> bool {
        self.nonce == other.nonce
            && self.gas_price == other.gas_price
            && self.gas_limit == other.gas_limit
            && self.kind == other.kind
            && self.value == other.value
            && self.input == other.input
            && self.signature == other.signature
    }
}

impl rlp::Encodable for LegacySignedTransaction {
    fn rlp_append(&self, s: &mut rlp::RlpStream) {
        s.begin_list(9);
        s.append(&self.nonce);
        s.append(&self.gas_price);
        s.append(&self.gas_limit);
        s.append(&self.kind);
        s.append(&self.value);
        s.append(&self.input.as_ref());
        s.append(&self.signature.v);
        s.append(&self.signature.r);
        s.append(&self.signature.s);
    }
}

impl rlp::Decodable for LegacySignedTransaction {
    fn decode(rlp: &rlp::Rlp<'_>) -> Result<Self, rlp::DecoderError> {
        if rlp.item_count()? != 9 {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }

        let v = rlp.val_at(6)?;
        let r = rlp.val_at::<U256>(7)?;
        let s = rlp.val_at::<U256>(8)?;

        Ok(Self {
            nonce: rlp.val_at(0)?,
            gas_price: rlp.val_at(1)?,
            gas_limit: rlp.val_at(2)?,
            kind: rlp.val_at(3)?,
            value: rlp.val_at(4)?,
            input: rlp.val_at::<Vec<u8>>(5)?.into(),
            signature: Signature { r, s, v },
            hash: OnceLock::new(),
        })
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use revm_primitives::Address;
    use secp256k1::SecretKey;

    use super::*;

    fn dummy_request() -> LegacyTransactionRequest {
        let to = Address::from_str("0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e").unwrap();
        let input = hex::decode("1234").unwrap();
        LegacyTransactionRequest {
            nonce: 1,
            gas_price: U256::from(2),
            gas_limit: 3,
            kind: TransactionKind::Call(to),
            value: U256::from(4),
            input: Bytes::from(input),
        }
    }

    fn dummy_private_key() -> SecretKey {
        SecretKey::from_str("e331b6d69882b4cb4ea581d88e0b604039a3de5967688d3dcffdd2270c0fd109")
            .unwrap()
    }

    #[test]
    fn test_legacy_signed_transaction_encoding() {
        // Generated by Hardhat
        let expected =
            hex::decode("f85f01020394c014ba5ec014ba5ec014ba5ec014ba5ec014ba5e048212341ca0c62d73a484ff7c53a0cfdf8eaa5e5896491b70971e9ce4a3e8750772b7c0203fa00562866909572aee9ab72df7470c1dd7aa29b056597be57c17e06f1ee303e7eb").unwrap();

        let request = dummy_request();
        let signed = request.sign(&dummy_private_key());

        let encoded = rlp::encode(&signed);
        assert_eq!(expected, encoded.to_vec());
    }

    #[test]
    fn test_legacy_signed_transaction_hash() {
        // Generated by hardhat
        let expected = B256::from_slice(
            &hex::decode("854a9427d54aaca361e7c592b4c3dc7da279c52a00cad157dab0365dcc27578d")
                .unwrap(),
        );

        let request = dummy_request();
        let signed = request.sign(&dummy_private_key());

        assert_eq!(expected, *signed.hash());
    }

    #[test]
    fn test_legacy_signed_transaction_rlp() {
        let request = dummy_request();
        let signed = request.sign(&dummy_private_key());

        let encoded = rlp::encode(&signed);
        assert_eq!(signed, rlp::decode(&encoded).unwrap());
    }
}
