use std::sync::OnceLock;

use bytes::Bytes;
use revm_primitives::{keccak256, Address, B256, U256};
use secp256k1::SecretKey;

use crate::{
    access_list::AccessListItem, signature::Signature, transaction::Eip4844SignedTransaction,
    utils::envelop_bytes,
};

#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(
    feature = "fastrlp",
    derive(open_fastrlp::RlpEncodable, open_fastrlp::RlpDecodable)
)]
pub struct Eip4844TransactionRequest {
    pub chain_id: u64,
    pub nonce: u64,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub max_fee_per_blob_gas: U256,
    pub gas_limit: u64,
    pub to: Address,
    pub value: U256,
    pub input: Bytes,
    pub access_list: Vec<AccessListItem>,
    pub blob_hashes: Vec<B256>,
}

impl Eip4844TransactionRequest {
    /// Computes the hash of the transaction.
    pub fn hash(&self) -> B256 {
        let encoded = rlp::encode(self);

        keccak256(&envelop_bytes(2, &encoded))
    }

    pub fn sign(self, private_key: &SecretKey) -> Eip4844SignedTransaction {
        let hash = self.hash();

        let signature = Signature::new(hash, private_key);

        Eip4844SignedTransaction {
            chain_id: self.chain_id,
            nonce: self.nonce,
            max_priority_fee_per_gas: self.max_priority_fee_per_gas,
            max_fee_per_gas: self.max_fee_per_gas,
            max_fee_per_blob_gas: self.max_fee_per_blob_gas,
            gas_limit: self.gas_limit,
            to: self.to,
            value: self.value,
            input: self.input,
            access_list: self.access_list.into(),
            blob_hashes: self.blob_hashes,
            odd_y_parity: signature.odd_y_parity(),
            r: signature.r,
            s: signature.s,
            hash: OnceLock::new(),
        }
    }
}

impl From<&Eip4844SignedTransaction> for Eip4844TransactionRequest {
    fn from(t: &Eip4844SignedTransaction) -> Self {
        Self {
            chain_id: t.chain_id,
            nonce: t.nonce,
            max_priority_fee_per_gas: t.max_priority_fee_per_gas,
            max_fee_per_gas: t.max_fee_per_gas,
            max_fee_per_blob_gas: t.max_fee_per_blob_gas,
            gas_limit: t.gas_limit,
            to: t.to,
            value: t.value,
            input: t.input.clone(),
            access_list: t.access_list.0.clone(),
            blob_hashes: t.blob_hashes.clone(),
        }
    }
}

impl rlp::Encodable for Eip4844TransactionRequest {
    fn rlp_append(&self, s: &mut rlp::RlpStream) {
        s.begin_list(11);
        s.append(&self.chain_id);
        s.append(&self.nonce);
        s.append(&self.max_priority_fee_per_gas);
        s.append(&self.max_fee_per_gas);
        s.append(&self.gas_limit);
        s.append(&self.to.as_bytes());
        s.append(&self.value);
        s.append(&self.input.as_ref());
        s.append_list(&self.access_list);
        s.append(&self.max_fee_per_blob_gas);

        let blob_hashes = self
            .blob_hashes
            .iter()
            .map(B256::as_bytes)
            .collect::<Vec<_>>();

        s.append_list::<&[u8], &[u8]>(blob_hashes.as_slice());
    }
}

#[cfg(test)]
mod tests {
    use std::str::FromStr;

    use revm_primitives::Address;

    use super::*;

    fn _dummy_request() -> Eip4844TransactionRequest {
        let to = Address::from_str("0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e").unwrap();
        let input = hex::decode("1234").unwrap();
        Eip4844TransactionRequest {
            chain_id: 1,
            nonce: 1,
            max_priority_fee_per_gas: U256::from(2),
            max_fee_per_gas: U256::from(5),
            max_fee_per_blob_gas: U256::from(7),
            gas_limit: 3,
            to,
            value: U256::from(4),
            input: Bytes::from(input),
            access_list: vec![AccessListItem {
                address: Address::zero(),
                storage_keys: vec![B256::zero(), B256::from(U256::from(1))],
            }],
            blob_hashes: vec![B256::zero(), B256::from(U256::from(1))],
        }
    }

    // TODO: add tests
    // #[test]
    // fn test_eip1559_transaction_request_encoding() {
    //     // Generated by Hardhat
    //     // QUESTION: What is considered a valid RLP-encoding? With the prepending type? or without?
    //     let expected =
    //         hex::decode("f87b010102050394c014ba5ec014ba5ec014ba5ec014ba5ec014ba5e04821234f85bf859940000000000000000000000000000000000000000f842a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001")
    //             .unwrap();

    //     let request = dummy_request();

    //     let encoded = rlp::encode(&request);
    //     assert_eq!(expected, encoded.to_vec());
    // }

    // #[test]
    // fn test_eip1559_transaction_request_encoding_empty() {
    //     // Generated by Hardhat
    //     let expected = hex::decode("c90180808080808080c0").unwrap();

    //     let empty = Eip4844TransactionRequest {
    //         chain_id: 1,
    //         nonce: 0,
    //         max_priority_fee_per_gas: U256::ZERO,
    //         max_fee_per_gas: U256::ZERO,
    //         gas_limit: 0,
    //         kind: TransactionKind::Create,
    //         value: U256::ZERO,
    //         input: Bytes::new(),
    //         access_list: vec![],
    //     };

    //     let encoded = rlp::encode(&empty);
    //     assert_eq!(expected, encoded.to_vec());
    // }

    // #[test]
    // fn test_eip1559_transaction_request_hash() {
    //     // Generated by hardhat
    //     let expected = B256::from_slice(
    //         &hex::decode("1d21c520c93f0f8e07c2466361b22a8bb9906cdbf4670e53a701c075bbe69ecf")
    //             .unwrap(),
    //     );

    //     let request = dummy_request();
    //     assert_eq!(expected, request.hash());
    // }
}
