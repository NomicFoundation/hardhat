use std::{io, ops::Deref, sync::Arc};

use edr_eth::B256;
use edr_evm::RandomHashGenerator;
use napi::{bindgen_prelude::Buffer, Status};
use napi_derive::napi;
use parking_lot::Mutex;

use crate::cast::TryCast;

#[napi]
#[derive(Debug)]
pub struct EdrContext {
    inner: Arc<Context>,
}

impl Deref for EdrContext {
    type Target = Arc<Context>;

    fn deref(&self) -> &Self::Target {
        &self.inner
    }
}

#[napi]
impl EdrContext {
    #[doc = "Creates a new [`EdrContext`] instance. Should only be called once!"]
    #[napi(constructor)]
    pub fn new() -> napi::Result<Self> {
        let context =
            Context::new().map_err(|e| napi::Error::new(Status::GenericFailure, e.to_string()))?;

        Ok(Self {
            inner: Arc::new(context),
        })
    }

    #[doc = "Overwrites the next value generated by the state root generator with the provided seed."]
    #[napi]
    pub fn set_state_root_generator_seed(&self, seed: Buffer) -> napi::Result<()> {
        let seed = TryCast::<B256>::try_cast(seed)?;

        self.inner.state_root_generator.lock().set_next(seed);

        Ok(())
    }
}

#[derive(Debug)]
pub struct Context {
    pub state_root_generator: Arc<Mutex<RandomHashGenerator>>,
}

impl Context {
    /// Creates a new [`Context`] instance. Should only be called once!
    pub fn new() -> io::Result<Self> {
        let state_root_generator = Arc::new(Mutex::new(RandomHashGenerator::with_seed(
            edr_defaults::STATE_ROOT_HASH_SEED,
        )));

        Ok(Self {
            state_root_generator,
        })
    }
}
